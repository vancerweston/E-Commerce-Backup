{"version":3,"file":"index.js","sources":["../../src/mongo.ts","../../src/accessible_records.ts","../../src/accessible_fields.ts"],"sourcesContent":["import { AnyMongoAbility, Abilities, AbilityTuple, AbilityParameters, Generics } from '@casl/ability';\nimport { rulesToQuery } from '@casl/ability/extra';\n\nfunction convertToMongoQuery(rule: AnyMongoAbility['rules'][number]) {\n  const conditions = rule.conditions!;\n  return rule.inverted ? { $nor: [conditions] } : conditions;\n}\n\ntype ToMongoQueryRestArgs<T extends Abilities> = AbilityParameters<\nT,\nT extends AbilityTuple ? (subject: T[1], action?: T[0]) => 0 : never,\n(subject: 'all' | undefined, action?: T) => 0\n>;\n\nexport function toMongoQuery<T extends AnyMongoAbility>(\n  ability: T,\n  ...args: ToMongoQueryRestArgs<Generics<T>['abilities']>\n) {\n  return (rulesToQuery as any)(ability, args[1] || 'read', args[0], convertToMongoQuery);\n}\n","import { Normalize, AnyMongoAbility, Generics } from '@casl/ability';\nimport { Schema, DocumentQuery, Query, Model, Document } from 'mongoose';\nimport { toMongoQuery } from './mongo';\n\nconst DENY_CONDITION_NAME = '__forbiddenByCasl__'; // eslint-disable-line\n\nfunction returnQueryResult(this: any, methodName: string, returnValue: any, ...args: any[]) {\n  const [conditions, , callback] = args;\n\n  if (conditions[DENY_CONDITION_NAME]) {\n    return typeof callback === 'function'\n      ? callback(null, returnValue)\n      : Promise.resolve(returnValue);\n  }\n\n  if (conditions.hasOwnProperty(DENY_CONDITION_NAME)) {\n    delete conditions[DENY_CONDITION_NAME];\n  }\n\n  return this[methodName].apply(this, args);\n}\n\nfunction emptifyQuery(query: DocumentQuery<Document, Document>) {\n  query.where({ [DENY_CONDITION_NAME]: 1 });\n  const privateQuery: any = query;\n  const collection = Object.create(privateQuery._collection); // eslint-disable-line\n  privateQuery._collection = collection; // eslint-disable-line\n  collection.find = returnQueryResult.bind(collection, 'find', []);\n  collection.findOne = returnQueryResult.bind(collection, 'findOne', null);\n  collection.count = returnQueryResult.bind(collection, 'count', 0);\n\n  return query;\n}\n\ntype GetAccessibleRecords<T extends Document> = <U extends AnyMongoAbility>(\n  ability: U,\n  action?: Normalize<Generics<U>['abilities']>[0]\n) => DocumentQuery<T, T>;\n\nfunction accessibleBy<T extends AnyMongoAbility>(\n  this: any,\n  ability: T,\n  action?: Normalize<Generics<T>['abilities']>[0]\n): DocumentQuery<Document, Document> {\n  let modelName: string | undefined = this.modelName;\n\n  if (!modelName) {\n    modelName = 'model' in this ? this.model.modelName : null;\n  }\n\n  if (!modelName) {\n    throw new TypeError('Cannot detect model name to return accessible records');\n  }\n\n  const toQuery = toMongoQuery as (...args: any[]) => ReturnType<typeof toMongoQuery>;\n  const query = toQuery(ability, modelName, action);\n\n  if (query === null) {\n    return emptifyQuery(this.where());\n  }\n\n  return this instanceof Query ? this.and([query]) : this.where({ $and: [query] });\n}\n\nexport interface AccessibleRecordModel<T extends Document, K = {}> extends Model<T, K & {\n  accessibleBy: GetAccessibleRecords<T>\n}> {\n  accessibleBy: GetAccessibleRecords<T>\n}\n\nexport function accessibleRecordsPlugin(schema: Schema<Document>) {\n  schema.query.accessibleBy = accessibleBy;\n  schema.statics.accessibleBy = accessibleBy;\n}\n","import { wrapArray, Normalize, AnyMongoAbility, Generics } from '@casl/ability';\nimport { permittedFieldsOf, PermittedFieldsOptions } from '@casl/ability/extra';\nimport { Schema, Model, Document } from 'mongoose';\n\nexport type AccessibleFieldsOptions =\n  { only: string | string[] } |\n  { except: string | string[] };\n\nfunction fieldsOf(schema: Schema<AccessibleFieldsDocument>, options?: AccessibleFieldsOptions) {\n  const fields = Object.keys((schema as any).paths);\n\n  if (!options || !('except' in options)) {\n    return fields;\n  }\n\n  const excludedFields = wrapArray(options.except);\n  return fields.filter(field => excludedFields.indexOf(field) === -1);\n}\n\ntype GetAccessibleFields<T extends AccessibleFieldsDocument> = <U extends AnyMongoAbility>(\n  this: Model<T> | T,\n  ability: U,\n  action?: Normalize<Generics<U>['abilities']>[0]\n) => string[];\n\nexport interface AccessibleFieldsModel<T extends AccessibleFieldsDocument> extends Model<T> {\n  accessibleFieldsBy: GetAccessibleFields<T>\n}\n\nexport interface AccessibleFieldsDocument extends Document {\n  accessibleFieldsBy: GetAccessibleFields<AccessibleFieldsDocument>\n}\n\nfunction modelFieldsGetter() {\n  let fieldsFrom: PermittedFieldsOptions<AnyMongoAbility>['fieldsFrom'];\n  return (schema: Schema<AccessibleFieldsDocument>, options?: AccessibleFieldsOptions) => {\n    if (!fieldsFrom) {\n      const ALL_FIELDS = options && 'only' in options\n        ? wrapArray(options.only)\n        : fieldsOf(schema, options);\n      fieldsFrom = rule => rule.fields || ALL_FIELDS;\n    }\n\n    return fieldsFrom;\n  };\n}\n\nexport function accessibleFieldsPlugin(\n  schema: Schema<AccessibleFieldsDocument>,\n  options?: AccessibleFieldsOptions\n) {\n  const fieldsFrom = modelFieldsGetter();\n  type ModelOrDoc = Model<AccessibleFieldsDocument> | AccessibleFieldsDocument;\n\n  function accessibleFieldsBy(this: ModelOrDoc, ability: AnyMongoAbility, action?: string) {\n    const subject = typeof this === 'function' ? this.modelName : this;\n    return permittedFieldsOf(ability, action || 'read', subject, {\n      fieldsFrom: fieldsFrom(schema, options)\n    });\n  }\n\n  schema.statics.accessibleFieldsBy = accessibleFieldsBy;\n  schema.method('accessibleFieldsBy', accessibleFieldsBy);\n}\n"],"names":["convertToMongoQuery","rule","conditions","inverted","$nor","toMongoQuery","ability","args","rulesToQuery","DENY_CONDITION_NAME","returnQueryResult","methodName","returnValue","callback","Promise","resolve","hasOwnProperty","apply","emptifyQuery","query","where","privateQuery","collection","Object","create","_collection","find","bind","findOne","count","accessibleBy","action","modelName","model","TypeError","toQuery","Query","and","$and","accessibleRecordsPlugin","schema","statics","fieldsOf","options","fields","keys","paths","excludedFields","wrapArray","except","filter","field","indexOf","modelFieldsGetter","fieldsFrom","ALL_FIELDS","only","accessibleFieldsPlugin","accessibleFieldsBy","subject","permittedFieldsOf","method"],"mappings":"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"}