'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var mongoose = require('mongoose');
var extra = require('@casl/ability/extra');
var ability = require('@casl/ability');

function convertToMongoQuery(rule) {
  const conditions = rule.conditions;
  return rule.inverted ? {
    $nor: [conditions]
  } : conditions;
}

function toMongoQuery(ability, ...args) {
  return extra.rulesToQuery(ability, args[1] || 'read', args[0], convertToMongoQuery);
}

const DENY_CONDITION_NAME = '__forbiddenByCasl__'; // eslint-disable-line

function returnQueryResult(methodName, returnValue, ...args) {
  const [conditions,, callback] = args;

  if (conditions[DENY_CONDITION_NAME]) {
    return typeof callback === 'function' ? callback(null, returnValue) : Promise.resolve(returnValue);
  }

  if (conditions.hasOwnProperty(DENY_CONDITION_NAME)) {
    delete conditions[DENY_CONDITION_NAME];
  }

  return this[methodName].apply(this, args);
}

function emptifyQuery(query) {
  query.where({
    [DENY_CONDITION_NAME]: 1
  });
  const privateQuery = query;
  const collection = Object.create(privateQuery._collection); // eslint-disable-line

  privateQuery._collection = collection; // eslint-disable-line

  collection.find = returnQueryResult.bind(collection, 'find', []);
  collection.findOne = returnQueryResult.bind(collection, 'findOne', null);
  collection.count = returnQueryResult.bind(collection, 'count', 0);
  return query;
}

function accessibleBy(ability, action) {
  let modelName = this.modelName;

  if (!modelName) {
    modelName = 'model' in this ? this.model.modelName : null;
  }

  if (!modelName) {
    throw new TypeError('Cannot detect model name to return accessible records');
  }

  const toQuery = toMongoQuery;
  const query = toQuery(ability, modelName, action);

  if (query === null) {
    return emptifyQuery(this.where());
  }

  return this instanceof mongoose.Query ? this.and([query]) : this.where({
    $and: [query]
  });
}

function accessibleRecordsPlugin(schema) {
  schema.query.accessibleBy = accessibleBy;
  schema.statics.accessibleBy = accessibleBy;
}

function fieldsOf(schema, options) {
  const fields = Object.keys(schema.paths);

  if (!options || !('except' in options)) {
    return fields;
  }

  const excludedFields = ability.wrapArray(options.except);
  return fields.filter(field => excludedFields.indexOf(field) === -1);
}

function modelFieldsGetter() {
  let fieldsFrom;
  return (schema, options) => {
    if (!fieldsFrom) {
      const ALL_FIELDS = options && 'only' in options ? ability.wrapArray(options.only) : fieldsOf(schema, options);

      fieldsFrom = rule => rule.fields || ALL_FIELDS;
    }

    return fieldsFrom;
  };
}

function accessibleFieldsPlugin(schema, options) {
  const fieldsFrom = modelFieldsGetter();

  function accessibleFieldsBy(ability, action) {
    const subject = typeof this === 'function' ? this.modelName : this;
    return extra.permittedFieldsOf(ability, action || 'read', subject, {
      fieldsFrom: fieldsFrom(schema, options)
    });
  }

  schema.statics.accessibleFieldsBy = accessibleFieldsBy;
  schema.method('accessibleFieldsBy', accessibleFieldsBy);
}

exports.accessibleFieldsPlugin = accessibleFieldsPlugin;
exports.accessibleRecordsPlugin = accessibleRecordsPlugin;
exports.toMongoQuery = toMongoQuery;
//# sourceMappingURL=index.js.map
