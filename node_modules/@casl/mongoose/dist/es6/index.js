import{Query as t}from"mongoose";import{rulesToQuery as n,permittedFieldsOf as e}from"@casl/ability/extra";import{wrapArray as o}from"@casl/ability";function i(t){const n=t.conditions;return t.inverted?{$nor:[n]}:n}function r(t,...e){return n(t,e[1]||"read",e[0],i)}function s(t,n,...e){const[o,,i]=e;return o.__forbiddenByCasl__?"function"==typeof i?i(null,n):Promise.resolve(n):(o.hasOwnProperty("__forbiddenByCasl__")&&delete o.__forbiddenByCasl__,this[t].apply(this,e))}function c(n,e){let o=this.modelName;if(o||(o="model"in this?this.model.modelName:null),!o)throw new TypeError("Cannot detect model name to return accessible records");const i=r(n,o,e);return null===i?function(t){t.where({__forbiddenByCasl__:1});const n=t,e=Object.create(n._collection);return n._collection=e,e.find=s.bind(e,"find",[]),e.findOne=s.bind(e,"findOne",null),e.count=s.bind(e,"count",0),t}(this.where()):this instanceof t?this.and([i]):this.where({$and:[i]})}function u(t){t.query.accessibleBy=c,t.statics.accessibleBy=c}const f=t=>Object.keys(t.paths);function l(){let t;return(n,e)=>{if(!t){const i=e&&"only"in e?o(e.only):function(t,n){const e=n.getFields(t);if(!n||!("except"in n))return e;const i=o(n.except);return e.filter(t=>-1===i.indexOf(t))}(n,e);t=t=>t.fields||i}return t}}function d(t,n){const o=Object.assign({getFields:f},n),i=l();function r(n,r){const s="function"==typeof this?this.modelName:this;return e(n,r||"read",s,{fieldsFrom:i(t,o)})}t.statics.accessibleFieldsBy=r,t.method("accessibleFieldsBy",r)}export{d as accessibleFieldsPlugin,u as accessibleRecordsPlugin,f as getSchemaPaths,r as toMongoQuery};
//# sourceMappingURL=index.js.map
