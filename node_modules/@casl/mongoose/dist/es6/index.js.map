{"version":3,"file":"index.js","sources":["../../src/mongo.ts","../../src/accessible_records.ts","../../src/accessible_fields.ts"],"sourcesContent":["import { AnyMongoAbility, Abilities, AbilityTuple, AbilityParameters, Generics } from '@casl/ability';\nimport { rulesToQuery } from '@casl/ability/extra';\n\nfunction convertToMongoQuery(rule: AnyMongoAbility['rules'][number]) {\n  const conditions = rule.conditions!;\n  return rule.inverted ? { $nor: [conditions] } : conditions;\n}\n\ntype ToMongoQueryRestArgs<T extends Abilities> = AbilityParameters<\nT,\nT extends AbilityTuple ? (subject: T[1], action?: T[0]) => 0 : never,\n(subject: 'all' | undefined, action?: T) => 0\n>;\n\nexport function toMongoQuery<T extends AnyMongoAbility>(\n  ability: T,\n  ...args: ToMongoQueryRestArgs<Generics<T>['abilities']>\n) {\n  return (rulesToQuery as any)(ability, args[1] || 'read', args[0], convertToMongoQuery);\n}\n","import { Normalize, AnyMongoAbility, Generics } from '@casl/ability';\nimport { Schema, DocumentQuery, Query, Model, Document } from 'mongoose';\nimport { toMongoQuery } from './mongo';\n\nconst DENY_CONDITION_NAME = '__forbiddenByCasl__'; // eslint-disable-line\n\nfunction returnQueryResult(this: any, methodName: string, returnValue: any, ...args: any[]) {\n  const [conditions, , callback] = args;\n\n  if (conditions[DENY_CONDITION_NAME]) {\n    return typeof callback === 'function'\n      ? callback(null, returnValue)\n      : Promise.resolve(returnValue);\n  }\n\n  if (conditions.hasOwnProperty(DENY_CONDITION_NAME)) {\n    delete conditions[DENY_CONDITION_NAME];\n  }\n\n  return this[methodName].apply(this, args);\n}\n\nfunction emptifyQuery(query: DocumentQuery<Document, Document>) {\n  query.where({ [DENY_CONDITION_NAME]: 1 });\n  const privateQuery: any = query;\n  const collection = Object.create(privateQuery._collection); // eslint-disable-line\n  privateQuery._collection = collection; // eslint-disable-line\n  collection.find = returnQueryResult.bind(collection, 'find', []);\n  collection.findOne = returnQueryResult.bind(collection, 'findOne', null);\n  collection.count = returnQueryResult.bind(collection, 'count', 0);\n\n  return query;\n}\n\ntype GetAccessibleRecords<T extends Document> = <U extends AnyMongoAbility>(\n  ability: U,\n  action?: Normalize<Generics<U>['abilities']>[0]\n) => DocumentQuery<T, T>;\n\nfunction accessibleBy<T extends AnyMongoAbility>(\n  this: any,\n  ability: T,\n  action?: Normalize<Generics<T>['abilities']>[0]\n): DocumentQuery<Document, Document> {\n  let modelName: string | undefined = this.modelName;\n\n  if (!modelName) {\n    modelName = 'model' in this ? this.model.modelName : null;\n  }\n\n  if (!modelName) {\n    throw new TypeError('Cannot detect model name to return accessible records');\n  }\n\n  const toQuery = toMongoQuery as (...args: any[]) => ReturnType<typeof toMongoQuery>;\n  const query = toQuery(ability, modelName, action);\n\n  if (query === null) {\n    return emptifyQuery(this.where());\n  }\n\n  return this instanceof Query ? this.and([query]) : this.where({ $and: [query] });\n}\n\nexport interface AccessibleRecordModel<T extends Document, K = {}> extends Model<T, K & {\n  accessibleBy: GetAccessibleRecords<T>\n}> {\n  accessibleBy: GetAccessibleRecords<T>\n}\n\nexport function accessibleRecordsPlugin(schema: Schema<Document>) {\n  schema.query.accessibleBy = accessibleBy;\n  schema.statics.accessibleBy = accessibleBy;\n}\n","import { wrapArray, Normalize, AnyMongoAbility, Generics } from '@casl/ability';\nimport { permittedFieldsOf, PermittedFieldsOptions } from '@casl/ability/extra';\nimport { Schema, Model, Document } from 'mongoose';\n\nexport type AccessibleFieldsOptions =\n  {\n    getFields(schema: Schema<Document>): string[]\n  } &\n  ({ only: string | string[] } | { except: string | string[] });\n\nexport const getSchemaPaths: AccessibleFieldsOptions['getFields'] = schema => Object.keys((schema as { paths: object }).paths);\n\nfunction fieldsOf(schema: Schema<Document>, options: Partial<AccessibleFieldsOptions>) {\n  const fields = options.getFields!(schema);\n\n  if (!options || !('except' in options)) {\n    return fields;\n  }\n\n  const excludedFields = wrapArray(options.except);\n  return fields.filter(field => excludedFields.indexOf(field) === -1);\n}\n\ntype GetAccessibleFields<T extends AccessibleFieldsDocument> = <U extends AnyMongoAbility>(\n  this: Model<T> | T,\n  ability: U,\n  action?: Normalize<Generics<U>['abilities']>[0]\n) => string[];\n\nexport interface AccessibleFieldsModel<T extends AccessibleFieldsDocument> extends Model<T> {\n  accessibleFieldsBy: GetAccessibleFields<T>\n}\n\nexport interface AccessibleFieldsDocument extends Document {\n  accessibleFieldsBy: GetAccessibleFields<AccessibleFieldsDocument>\n}\n\nfunction modelFieldsGetter() {\n  let fieldsFrom: PermittedFieldsOptions<AnyMongoAbility>['fieldsFrom'];\n  return (schema: Schema<Document>, options: Partial<AccessibleFieldsOptions>) => {\n    if (!fieldsFrom) {\n      const ALL_FIELDS = options && 'only' in options\n        ? wrapArray(options.only as string[])\n        : fieldsOf(schema, options);\n      fieldsFrom = rule => rule.fields || ALL_FIELDS;\n    }\n\n    return fieldsFrom;\n  };\n}\n\nexport function accessibleFieldsPlugin(\n  schema: Schema<AccessibleFieldsDocument>,\n  rawOptions?: Partial<AccessibleFieldsOptions>\n) {\n  const options = { getFields: getSchemaPaths, ...rawOptions };\n  const fieldsFrom = modelFieldsGetter();\n  type ModelOrDoc = Model<AccessibleFieldsDocument> | AccessibleFieldsDocument;\n\n  function accessibleFieldsBy(this: ModelOrDoc, ability: AnyMongoAbility, action?: string) {\n    const subject = typeof this === 'function' ? this.modelName : this;\n    return permittedFieldsOf(ability, action || 'read', subject, {\n      fieldsFrom: fieldsFrom(schema, options)\n    });\n  }\n\n  schema.statics.accessibleFieldsBy = accessibleFieldsBy;\n  schema.method('accessibleFieldsBy', accessibleFieldsBy);\n}\n"],"names":["convertToMongoQuery","rule","conditions","inverted","$nor","toMongoQuery","ability","args","rulesToQuery","returnQueryResult","methodName","returnValue","callback","Promise","resolve","hasOwnProperty","this","apply","accessibleBy","action","modelName","model","TypeError","query","where","privateQuery","collection","Object","create","_collection","find","bind","findOne","count","emptifyQuery","Query","and","$and","accessibleRecordsPlugin","schema","statics","getSchemaPaths","keys","paths","modelFieldsGetter","fieldsFrom","options","ALL_FIELDS","wrapArray","only","fields","getFields","excludedFields","except","filter","field","indexOf","fieldsOf","accessibleFieldsPlugin","rawOptions","accessibleFieldsBy","subject","permittedFieldsOf","method"],"mappings":"qJAGA,SAASA,EAAoBC,SACrBC,EAAaD,EAAKC,kBACjBD,EAAKE,SAAW,CAAEC,KAAM,CAACF,IAAgBA,EAS3C,SAASG,EACdC,KACGC,UAEKC,EAAqBF,EAASC,EAAK,IAAM,OAAQA,EAAK,GAAIP,GCZpE,SAASS,EAA6BC,EAAoBC,KAAqBJ,SACtEL,GAAcU,GAAYL,SAE7BL,EAAU,oBACe,mBAAbU,EACVA,EAAS,KAAMD,GACfE,QAAQC,QAAQH,IAGlBT,EAAWa,eAXW,+BAYjBb,EAAU,oBAGZc,KAAKN,GAAYO,MAAMD,KAAMT,IAoBtC,SAASW,EAEPZ,EACAa,OAEIC,EAAgCJ,KAAKI,aAEpCA,IACHA,EAAY,UAAWJ,KAAOA,KAAKK,MAAMD,UAAY,OAGlDA,QACG,IAAIE,UAAU,+DAIhBC,EADUlB,EACMC,EAASc,EAAWD,UAE5B,OAAVI,EAnCN,SAAsBA,GACpBA,EAAMC,MAAM,qBAAyB,UAC/BC,EAAoBF,EACpBG,EAAaC,OAAOC,OAAOH,EAAaI,oBAC9CJ,EAAaI,YAAcH,EAC3BA,EAAWI,KAAOrB,EAAkBsB,KAAKL,EAAY,OAAQ,IAC7DA,EAAWM,QAAUvB,EAAkBsB,KAAKL,EAAY,UAAW,MACnEA,EAAWO,MAAQxB,EAAkBsB,KAAKL,EAAY,QAAS,GAExDH,EA2BEW,CAAalB,KAAKQ,SAGpBR,gBAAgBmB,EAAQnB,KAAKoB,IAAI,CAACb,IAAUP,KAAKQ,MAAM,CAAEa,KAAM,CAACd,KASlE,SAASe,EAAwBC,GACtCA,EAAOhB,MAAML,aAAeA,EAC5BqB,EAAOC,QAAQtB,aAAeA,QC9DnBuB,EAAuDF,GAAUZ,OAAOe,KAAMH,EAA6BI,OA2BxH,SAASC,QACHC,QACG,CAACN,EAA0BO,SAC3BD,EAAY,OACTE,EAAaD,GAAW,SAAUA,EACpCE,EAAUF,EAAQG,MA9B5B,SAAkBV,EAA0BO,SACpCI,EAASJ,EAAQK,UAAWZ,OAE7BO,KAAa,WAAYA,UACrBI,QAGHE,EAAiBJ,EAAUF,EAAQO,eAClCH,EAAOI,OAAOC,IAA4C,IAAnCH,EAAeI,QAAQD,IAuB7CE,CAASlB,EAAQO,GACrBD,EAAa5C,GAAQA,EAAKiD,QAAUH,SAG/BF,GAIJ,SAASa,EACdnB,EACAoB,SAEMb,iBAAYK,UAAWV,GAAmBkB,GAC1Cd,EAAaD,aAGVgB,EAAqCtD,EAA0Ba,SAChE0C,EAA0B,mBAAT7C,KAAsBA,KAAKI,UAAYJ,YACvD8C,EAAkBxD,EAASa,GAAU,OAAQ0C,EAAS,CAC3DhB,WAAYA,EAAWN,EAAQO,KAInCP,EAAOC,QAAQoB,mBAAqBA,EACpCrB,EAAOwB,OAAO,qBAAsBH"}